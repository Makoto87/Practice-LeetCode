## 問題  
[703. Kth Largest Element in a Stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/)  
<br>
## 書いたコード
```go
type KthLargest struct {
    items []int
    k int
}

// 初期化作業
func Constructor(k int, nums []int) KthLargest {
    newKthLargest := KthLargest{k: k}
    // 最小ヒープで値を追加していく
    for _, v := range nums {
        newKthLargest.HeapAdd(v)
    }
    
    // k番目の値が最小値になるまで先頭を削除する
    // 言い換えると、k個になるまでスライスの先頭を削除
    newKthLargest.DeleteNodes()
    return newKthLargest
}

// addしてk番目の値を返す
func (this *KthLargest) Add(val int) int {
    this.HeapAdd(val)
    // k番目の値が最小値になるまで先頭を削除する
    this.DeleteNodes()
    // 先頭 = k番目の値
    return this.items[0]
}

// k番目の値が最小値になるまで先頭を削除する
func (this *KthLargest) DeleteNodes() {
    for len(this.items) > this.k {
        this.items = this.items[1:]
    }
}

// 最小ヒープでadd
func (this *KthLargest) HeapAdd(val int) {
    this.items = append(this.items, val)
    // 親ノードになるノードを、末尾から順番に処理していく
    for i := len(this.items) / 2; i >= 0; i-- {
        this.items = minHeapify(this.items, i)
    }
}

// 最小ヒープ
func minHeapify(array []int, i int) []int {
    smallest := i
    // 左の子ノード
    l := 2 * i
    // 右の子ノード
    r := 2 * i + 1
    length := len(array) - 1
    
    // 左の子ノードの値が最小になる場合
    if length >= l && array[l] < array[smallest] {
        smallest = l
    }
    // 右の子ノードの値が最小になる場合
    if length >= r && array[r] < array[smallest] {
        smallest = r
    }
    // 現在のノードより子ノードの方が小さい場合、値を入れ替える
    if smallest != i {
        temp := array[i]
        array[i] = array[smallest]
        array[smallest] = temp
        // 入れ替えた後に最小ヒープとなっているか再帰して確かめる
        return minHeapify(array, smallest)
    }
    return array
}


/**
 * Your KthLargest object will be instantiated and called as such:
 * obj := Constructor(k, nums);
 * param_1 := obj.Add(val);
 */
```
<br>

## 解説  
この問題は、最初に配列を用意し、配列に値を追加するたびにk番目に大きい値を返すという問題です。  
初めに構造体（クラス）を作成する処理では配列とk番目が何になるかの数字が与えられますが、nilを返します。  
その後に、Addで配列に値を追加し、k番目に大きい値を返します。  

初期化・Addするたびに配列をソートし、k番目の値を返すというやり方でもできますが、時間計算量が膨大になります。  
そこで最小ヒープを使って、時間計算量を工夫する必要があります。  

ヒープとはなんぞやという方は下記のリンクを参考にしてください。  
[ヒープをわかりやすく解説してみた](https://medium.com/@yasufumy/data-structure-heap-ecfd0989e5be)  

最小ヒープにすると、配列の先頭が常に最小の値になります。  
最小ヒープとなった配列の先頭を、k個になるまで削除し続ければ、配列の先頭がk番目に大きいということになります。  
また、配列をk個に保つことで、Addされても少ない計算量で処理することができます。  

僕のコードは一応最小ヒープを使いましたが、Runtimeが571 msでかなり時間がかかりました。  
もっと良い解き方があると思います。  

時間計算量はO(N)  
空間計算量はO(1)


## 参考にしたもの  
[ヒープをわかりやすく解説してみた](https://medium.com/@yasufumy/data-structure-heap-ecfd0989e5be)